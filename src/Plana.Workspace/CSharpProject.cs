// ------------------------------------------------------------------------------------------
//  Copyright (c) Natsuneko. All rights reserved.
//  Licensed under the MIT License. See LICENSE in the project root for license information.
// ------------------------------------------------------------------------------------------

using Microsoft.CodeAnalysis;

using Plana.Composition.Abstractions.Analysis;
using Plana.Logging.Abstractions;

namespace Plana.Workspace;

public class CSharpProject : IProject
{
    private readonly PlanaWorkspaceContext _context;
    private readonly Project _project;
    private readonly ILogger? _logger;
    private readonly List<CSharpDocument> _documents;

    private CSharpProject(PlanaWorkspaceContext context, Project project, List<CSharpDocument> documents, ILogger? logger)
    {
        _context = context;
        _project = project;
        _documents = documents;
        _logger = logger;
    }

    public Guid Id => _project.Id.Id;

    public string Name => _project.Name;

    public IReadOnlyCollection<IDocument> Documents => _documents.AsReadOnly();

    internal static async Task<IProject> CreateProject(PlanaWorkspaceContext context, Project project, ILogger? logger, CancellationToken ct)
    {
        var documents = new List<CSharpDocument>();
        var path = new Uri(Path.GetDirectoryName(project.FilePath)!);

        foreach (var document in project.Documents)
        {
            ct.ThrowIfCancellationRequested();

            var isGeneratedDocument = await IsDocumentIsAutoGeneratedAsync(document, ct);
            if (isGeneratedDocument || document.FilePath == null || !path.IsBaseOf(new Uri(document.FilePath)))
            {
                logger?.LogWarning($"the file {document.FilePath} will ignored because located outside of project");
                continue;
            }

            var d = (CSharpDocument)await CSharpDocument.CreateDocumentAsync(context, document, ct);
            documents.Add(d);
        }

        return new CSharpProject(context, project, documents, logger);
    }

    private static readonly string[] Autogenerated = ["<auto-generated", "<autogenerated"];

    private static async Task<bool> IsDocumentIsAutoGeneratedAsync(Document document, CancellationToken ct)
    {
        var node = await document.GetSyntaxRootAsync(ct);
        if (node is { HasLeadingTrivia: true })
        {
            var leading = node.GetLeadingTrivia();
            foreach (var trivia in leading)
            {
                var text = trivia.ToFullString();
                if (Autogenerated.Any(w => text.Contains(w)))
                    return true;
            }
        }

        return false;
    }
}